// üìÑ scripts/testDynamicOdds.js - SCRIPT DE PRUEBA COMPLETO
// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

require('dotenv').config();
const { BettingMarket, Odds } = require('../src/models');
const dynamicOddsMapper = require('../src/utils/dynamicOddsMapper.service');
const logger = require('../src/utils/logger');

// ‚úÖ DATOS DE PRUEBA BASADOS EN TU paste.txt
const SAMPLE_API_FOOTBALL_DATA = {
  fixture: {
    id: 1340318,
    date: "2025-07-02T20:00:00+00:00",
    timezone: "UTC"
  },
  league: {
    id: 281,
    name: "Primera Divisi√≥n",
    country: "Peru"
  },
  bookmakers: [
    {
      id: 8,
      name: "Bet365",
      bets: [
        {
          id: 1,
          name: "Match Winner",
          values: [
            { value: "Home", odd: "4.10" },
            { value: "Draw", odd: "2.90" },
            { value: "Away", odd: "2.05" }
          ]
        },
        {
          id: 5,
          name: "Goals Over/Under",
          values: [
            { value: "Over 1.5", odd: "1.36" },
            { value: "Under 1.5", odd: "3.00" },
            { value: "Over 2.5", odd: "2.25" },
            { value: "Under 2.5", odd: "1.62" }
          ]
        },
        {
          id: 8,
          name: "Both Teams Score",
          values: [
            { value: "Yes", odd: "1.91" },
            { value: "No", odd: "1.80" }
          ]
        },
        {
          id: 21,
          name: "Odd/Even",
          values: [
            { value: "Odd", odd: "2.05" },
            { value: "Even", odd: "1.80" }
          ]
        },
        {
          id: 92,
          name: "Anytime Goal Scorer",
          values: [
            { value: "Daniel Meneses", odd: "12.00" },
            { value: "Jose Yabiku", odd: "3.40" },
            { value: "Bernardo Cuesta", odd: "2.30" }
          ]
        }
      ]
    }
  ]
};

class DynamicOddsTest {
  async runCompleteTest() {
    try {
      console.log('üß™ INICIANDO PRUEBA COMPLETA DE ODDS DIN√ÅMICAS');
      console.log('‚ïê'.repeat(70));

      // 1. Verificar sistema b√°sico
      await this.testBasicSystem();
      
      // 2. Probar mapeo din√°mico
      await this.testDynamicMapping();
      
      // 3. Simular procesamiento completo
      await this.testCompleteProcessing();
      
      // 4. Verificar base de datos
      await this.testDatabaseState();
      
      // 5. Probar categorizaci√≥n
      await this.testCategorization();

      console.log('\n‚úÖ ¬°TODAS LAS PRUEBAS PASARON EXITOSAMENTE!');
      console.log('üéØ Tu sistema de odds din√°micas est√° funcionando correctamente');

    } catch (error) {
      console.error('‚ùå ERROR EN PRUEBAS:', error.message);
      throw error;
    }
  }

  // ‚úÖ PRUEBA 1: Sistema b√°sico
  async testBasicSystem() {
    console.log('\nüîß PRUEBA 1: Verificando sistema b√°sico...');
    
    try {
      // Verificar que el mapper existe
      const mapperStats = dynamicOddsMapper.getMappingStats();
      console.log(`   ‚úÖ Mapper din√°mico cargado: ${mapperStats.supportedCategories} categor√≠as`);
      
      // Verificar base de datos
      const marketCount = await BettingMarket.count();
      console.log(`   ‚úÖ Base de datos conectada: ${marketCount} mercados existentes`);
      
      // Verificar nuevas columnas
      const sampleMarket = await BettingMarket.findOne();
      if (sampleMarket && typeof sampleMarket.apiFootballId !== 'undefined') {
        console.log('   ‚úÖ Nuevas columnas din√°micas disponibles');
      } else {
        console.log('   ‚ö†Ô∏è Columnas din√°micas no encontradas - ejecutar migraci√≥n');
      }

    } catch (error) {
      console.error('   ‚ùå Error en sistema b√°sico:', error.message);
      throw error;
    }
  }

  // ‚úÖ PRUEBA 2: Mapeo din√°mico
  async testDynamicMapping() {
    console.log('\nüéØ PRUEBA 2: Probando mapeo din√°mico...');
    
    try {
      for (const bet of SAMPLE_API_FOOTBALL_DATA.bookmakers[0].bets) {
        console.log(`\n   üîÑ Procesando: ${bet.name} (ID: ${bet.id})`);
        
        // Mapear mercado din√°micamente
        const mappedMarket = await dynamicOddsMapper.mapMarketDynamically(bet);
        
        console.log(`      üìä Clave generada: ${mappedMarket.key}`);
        console.log(`      üìã Categor√≠a detectada: ${mappedMarket.category}`);
        console.log(`      üéØ Prioridad: ${mappedMarket.priority}`);
        console.log(`      üìà Outcomes: ${mappedMarket.possibleOutcomes.length}`);
        
        // Probar normalizaci√≥n de outcomes
        bet.values.forEach(value => {
          const normalized = dynamicOddsMapper.normalizeOutcome(value.value);
          console.log(`         "${value.value}" ‚Üí "${normalized}"`);
        });
      }
      
      console.log('   ‚úÖ Mapeo din√°mico funcionando correctamente');

    } catch (error) {
      console.error('   ‚ùå Error en mapeo din√°mico:', error.message);
      throw error;
    }
  }

  // ‚úÖ PRUEBA 3: Procesamiento completo
  async testCompleteProcessing() {
    console.log('\n‚öôÔ∏è PRUEBA 3: Simulando procesamiento completo...');
    
    try {
      const results = {
        marketsProcessed: 0,
        oddsCreated: 0,
        newMarkets: 0,
        errors: 0
      };

      for (const bet of SAMPLE_API_FOOTBALL_DATA.bookmakers[0].bets) {
        try {
          // Simular creaci√≥n de mercado
          const mappedMarket = await dynamicOddsMapper.mapMarketDynamically(bet);
          
          // Buscar o crear mercado
          const [market, wasCreated] = await BettingMarket.findOrCreate({
            where: { apiFootballId: bet.id },
            defaults: {
              ...mappedMarket,
              isActive: true
            }
          });

          if (wasCreated) {
            results.newMarkets++;
            console.log(`      ‚ûï Nuevo mercado creado: ${market.name}`);
          } else {
            console.log(`      üîÑ Mercado existente actualizado: ${market.name}`);
            await market.update({
              usageCount: (market.usageCount || 0) + 1,
              lastSeenAt: new Date()
            });
          }

          results.marketsProcessed++;
          results.oddsCreated += bet.values.length;

        } catch (error) {
          console.error(`      ‚ùå Error procesando ${bet.name}:`, error.message);
          results.errors++;
        }
      }

      console.log(`   üìä Resultados del procesamiento:`);
      console.log(`      üìà Mercados procesados: ${results.marketsProcessed}`);
      console.log(`      üÜï Nuevos mercados: ${results.newMarkets}`);
      console.log(`      üíæ Odds procesadas: ${results.oddsCreated}`);
      console.log(`      ‚ùå Errores: ${results.errors}`);

      if (results.errors === 0) {
        console.log('   ‚úÖ Procesamiento completo exitoso');
      }

    } catch (error) {
      console.error('   ‚ùå Error en procesamiento:', error.message);
      throw error;
    }
  }

  // ‚úÖ PRUEBA 4: Estado de base de datos
  async testDatabaseState() {
    console.log('\nüíæ PRUEBA 4: Verificando estado de base de datos...');
    
    try {
      // Contar mercados por categor√≠a
      const markets = await BettingMarket.findAll({
        where: { apiFootballId: { [require('sequelize').Op.ne]: null } },
        attributes: ['category', 'apiFootballId', 'usageCount', 'lastSeenAt']
      });

      const categoryStats = {};
      markets.forEach(market => {
        const cat = market.category || 'OTHER';
        if (!categoryStats[cat]) {
          categoryStats[cat] = 0;
        }
        categoryStats[cat]++;
      });

      console.log('   üìä Mercados por categor√≠a:');
      Object.entries(categoryStats).forEach(([category, count]) => {
        console.log(`      üìã ${category}: ${count} mercados`);
      });

      // Verificar odds
      const oddsCount = await Odds.count();
      console.log(`   üí∞ Total de odds en sistema: ${oddsCount}`);

      console.log('   ‚úÖ Base de datos en estado saludable');

    } catch (error) {
      console.error('   ‚ùå Error verificando base de datos:', error.message);
      throw error;
    }
  }

  // ‚úÖ PRUEBA 5: Categorizaci√≥n
  async testCategorization() {
    console.log('\nüè∑Ô∏è PRUEBA 5: Probando categorizaci√≥n autom√°tica...');
    
    try {
      const testCases = [
        { name: "Match Winner", expected: "MATCH_RESULT" },
        { name: "Goals Over/Under", expected: "GOALS" },
        { name: "Both Teams Score", expected: "GOALS" },
        { name: "First Half Winner", expected: "HALFTIME" },
        { name: "Corners Over Under", expected: "CORNERS" },
        { name: "Anytime Goal Scorer", expected: "PLAYER_PROPS" },
        { name: "Odd/Even", expected: "SPECIALS" },
        { name: "Unknown Market Type", expected: "OTHER" }
      ];

      let correct = 0;
      let total = testCases.length;

      for (const testCase of testCases) {
        const detected = dynamicOddsMapper.detectCategory(testCase.name);
        const isCorrect = detected === testCase.expected;
        
        console.log(`      ${isCorrect ? '‚úÖ' : '‚ùå'} "${testCase.name}" ‚Üí ${detected} ${isCorrect ? '' : `(esperado: ${testCase.expected})`}`);
        
        if (isCorrect) correct++;
      }

      console.log(`   üìä Precisi√≥n de categorizaci√≥n: ${correct}/${total} (${Math.round(correct/total*100)}%)`);
      
      if (correct >= total * 0.8) { // 80% de precisi√≥n m√≠nima
        console.log('   ‚úÖ Categorizaci√≥n funcionando correctamente');
      } else {
        console.log('   ‚ö†Ô∏è Categorizaci√≥n necesita mejoras');
      }

    } catch (error) {
      console.error('   ‚ùå Error en categorizaci√≥n:', error.message);
      throw error;
    }
  }

  // ‚úÖ PRUEBA ESPEC√çFICA: Verificar estructura de API-Football
  async testApiFootballStructure() {
    console.log('\nüîç PRUEBA ADICIONAL: Verificando estructura de API-Football...');
    
    try {
      // Verificar que la estructura coincida con tu paste.txt
      const sampleBookmaker = SAMPLE_API_FOOTBALL_DATA.bookmakers[0];
      
      console.log(`   üìä Bookmaker: ${sampleBookmaker.name}`);
      console.log(`   üìã Mercados disponibles: ${sampleBookmaker.bets.length}`);
      
      sampleBookmaker.bets.forEach(bet => {
        console.log(`      üéØ ${bet.name}: ${bet.values.length} outcomes`);
        
        bet.values.forEach(value => {
          const odds = parseFloat(value.odd);
          const impliedProb = ((1 / odds) * 100).toFixed(1);
          console.log(`         "${value.value}": ${value.odd} (${impliedProb}%)`);
        });
      });

      console.log('   ‚úÖ Estructura compatible con API-Football');

    } catch (error) {
      console.error('   ‚ùå Error verificando estructura:', error.message);
    }
  }

  // ‚úÖ GENERAR REPORTE FINAL
  async generateFinalReport() {
    try {
      const mapperStats = dynamicOddsMapper.getMappingStats();
      const totalMarkets = await BettingMarket.count();
      const dynamicMarkets = await BettingMarket.count({
        where: { apiFootballId: { [require('sequelize').Op.ne]: null } }
      });

      console.log('\nüìä REPORTE FINAL DEL SISTEMA DIN√ÅMICO');
      console.log('‚ïê'.repeat(50));
      console.log(`üéØ Categor√≠as soportadas: ${mapperStats.supportedCategories}`);
      console.log(`üîß Normalizadores de outcomes: ${mapperStats.outcomeNormalizers}`);
      console.log(`üíæ Total mercados en BD: ${totalMarkets}`);
      console.log(`‚ö° Mercados din√°micos: ${dynamicMarkets}`);
      console.log(`üìà Cobertura din√°mica: ${Math.round((dynamicMarkets/totalMarkets)*100)}%`);
      console.log(`‚úÖ Sistema din√°mico: ${mapperStats.dynamicMapping ? 'ACTIVO' : 'INACTIVO'}`);
      
    } catch (error) {
      console.error('‚ùå Error generando reporte:', error.message);
    }
  }
}

// ‚úÖ EJECUTAR PRUEBAS
if (require.main === module) {
  const test = new DynamicOddsTest();
  
  const args = process.argv.slice(2);
  
  if (args.includes('--structure')) {
    test.testApiFootballStructure()
      .then(() => process.exit(0))
      .catch(() => process.exit(1));
  } else if (args.includes('--report')) {
    test.generateFinalReport()
      .then(() => process.exit(0))
      .catch(() => process.exit(1));
  } else {
    test.runCompleteTest()
      .then(() => test.generateFinalReport())
      .then(() => {
        console.log('\nüéØ Pruebas adicionales:');
        console.log('   node scripts/testDynamicOdds.js --structure');
        console.log('   node scripts/testDynamicOdds.js --report');
        process.exit(0);
      })
      .catch((error) => {
        console.error('\nüí• Pruebas fallaron:', error.message);
        process.exit(1);
      });
  }
}

module.exports = DynamicOddsTest;